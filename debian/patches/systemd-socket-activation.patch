From: Steve Langasek <steve.langasek@ubuntu.com>
Date: Thu, 1 Sep 2022 16:03:37 +0100
Subject: Support systemd socket activation

Description: support systemd socket activation
 Unlike inetd socket activation, with systemd socket activation the
 supervisor passes the listened-on socket to the child process and lets
 the child process handle the accept().  This lets us do delayed start
 of the sshd daemon without becoming incompatible with config options
 like ClientAliveCountMax.

Author: Steve Langasek <steve.langasek@ubuntu.com>
Author: Nick Rosbrook <nick.rosbrook@canonical.com>
Author: Colin Watson <cjwatson@debian.org>
Author: Marco Trevisan <marco@ubuntu.com>
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/openssh/+bug/2011458
Last-Update: 2024-04-03

---
 configure.ac |   1 +
 sshd.c       | 176 ++++++++++++++++++++++++++++++++++++++++++++++++++++-------
 2 files changed, 156 insertions(+), 21 deletions(-)

--- a/configure.ac
+++ b/configure.ac
@@ -932,6 +932,7 @@
 	AC_DEFINE([USE_BTMP])
 	AC_DEFINE([LINUX_OOM_ADJUST], [1], [Adjust Linux out-of-memory killer])
 	AC_DEFINE([SYSTEMD_NOTIFY], [1], [Have sshd notify systemd on start/reload])
+	AC_DEFINE([SYSTEMD_SOCKET_ACTIVATION], [1], [Have sshd accept systemd socket activation])
 	inet6_default_4in6=yes
 	case `uname -r` in
 	1.*|2.0.*)
--- a/sshd.c
+++ b/sshd.c
@@ -47,6 +47,7 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
+#include <linux/vm_sockets.h>
 #ifdef HAVE_SYS_STAT_H
 # include <sys/stat.h>
 #endif
@@ -135,11 +136,18 @@
 int deny_severity;
 #endif /* LIBWRAP */
 
+/* This will only get set if we build with systemd. */
+static int systemd_num_listen_fds;
+
+#ifdef SYSTEMD_SOCKET_ACTIVATION
+#define SYSTEMD_LISTEN_FDS_START 3
+#endif
+
 /* Re-exec fds */
-#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
-#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
-#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
-#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)
+#define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1 + systemd_num_listen_fds)
+#define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2 + systemd_num_listen_fds)
+#define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3 + systemd_num_listen_fds)
+#define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4 + systemd_num_listen_fds)
 
 extern char *__progname;
 
@@ -190,6 +198,7 @@
  */
 #define	MAX_LISTEN_SOCKS	16
 static int listen_socks[MAX_LISTEN_SOCKS];
+static int listen_socks_no_close[MAX_LISTEN_SOCKS];
 static int num_listen_socks = 0;
 
 /* Daemon's agent connection */
@@ -275,12 +284,16 @@
  * Close all listening sockets
  */
 static void
-close_listen_socks(void)
+close_listen_socks(int force)
 {
 	int i;
 
-	for (i = 0; i < num_listen_socks; i++)
+	for (i = 0; i < num_listen_socks; i++) {
+		if (listen_socks_no_close[i] > 0 && force <= 0)
+			continue;
+
 		close(listen_socks[i]);
+        }
 	num_listen_socks = 0;
 }
 
@@ -318,7 +331,7 @@
 	if (options.pid_file != NULL)
 		unlink(options.pid_file);
 	platform_pre_restart();
-	close_listen_socks();
+	close_listen_socks(/* force = */ 0);
 	close_startup_pipes();
 	ssh_signal(SIGHUP, SIG_IGN); /* will be restored after exec */
 	execv(saved_argv[0], saved_argv);
@@ -1016,6 +1029,133 @@
 	debug("inetd sockets after dupping: %d, %d", *sock_in, *sock_out);
 }
 
+#ifdef SYSTEMD_SOCKET_ACTIVATION
+/*
+ * Get file descriptors passed by systemd; this implements the protocol
+ * described in the NOTES section of sd_listen_fds(3), with a few exceptions
+ * to handle our needs in sshd.
+ */
+static int
+get_systemd_listen_fds(void)
+{
+	const char *listen_pid_str, *listen_fds_str;
+	pid_t listen_pid;
+	int listen_fds;
+	const char *errstr = NULL;
+	int fd;
+
+	/* When we have been re-executed, do not check $LISTEN_PID because it will
+	 * not match, but we still need to check $LISTEN_FDS. */
+	if (!rexeced_flag) {
+	        listen_pid_str = getenv("LISTEN_PID");
+	        if (listen_pid_str == NULL)
+	                return 0;
+	        listen_pid = (pid_t)strtonum(listen_pid_str, 2, INT_MAX, &errstr);
+	        if (errstr != NULL)
+	                return -errno;
+	        if (getpid() != listen_pid)
+	                return 0;
+	}
+
+	listen_fds_str = getenv("LISTEN_FDS");
+	if (listen_fds_str == NULL)
+		return 0;
+	listen_fds = (int)strtonum(listen_fds_str, 1,
+	    INT_MAX - SYSTEMD_LISTEN_FDS_START, &errstr);
+	if (errstr != NULL)
+		return -errno;
+
+	return listen_fds;
+}
+
+/*
+ * Configure our socket fds that were passed from systemd
+ */
+static void
+setup_systemd_socket(int listen_sock)
+{
+	int flags, ret;
+	struct sockaddr_storage addr;
+	socklen_t len = sizeof(addr);
+	char *listen_on_str = NULL;
+	sa_family_t family;
+
+	if (getsockname(listen_sock, (struct sockaddr *)&addr, &len) != 0)
+		return;
+
+	if (num_listen_socks >= MAX_LISTEN_SOCKS)
+		fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
+
+	family = ((struct sockaddr *)&addr)->sa_family;
+
+	switch (family) {
+	case AF_INET:
+	case AF_INET6:
+		char host[NI_MAXHOST] = {}, strport[NI_MAXSERV] = {};
+
+	        ret = getnameinfo((struct sockaddr *)&addr, len,
+	                          host, sizeof(host),
+	                          strport, sizeof(strport),
+	                          NI_NUMERICHOST|NI_NUMERICSERV);
+	        if (ret != 0) {
+	                error("getnameinfo failed: %.100s", ssh_gai_strerror(ret));
+	                close(listen_sock);
+	                return;
+	        }
+
+	        xasprintf(&listen_on_str, "%s port %s.", host, strport);
+	        break;
+
+	case AF_VSOCK:
+	        struct sockaddr_vm *vm = (struct sockaddr_vm *)&addr;
+
+	        if (vm->svm_cid == VMADDR_CID_ANY)
+	                xasprintf(&listen_on_str, "vsock::%u", vm->svm_port);
+	        else
+	                xasprintf(&listen_on_str, "vsock:%u:%u", vm->svm_cid, vm->svm_port);
+	        break;
+
+	default:
+	        error("Unsupported address family %d, closing", family);
+	        close(listen_sock);
+	        return;
+	}
+
+	if (set_nonblock(listen_sock) == -1) {
+		close(listen_sock);
+	        free(listen_on_str);
+		return;
+	}
+
+	/* Socket options */
+	set_reuseaddr(listen_sock);
+
+	/* systemd sets FD_CLOEXEC on the fds it passes to us, but we need this
+	 * to stay open across re-exec. */
+	flags = fcntl(listen_sock, F_GETFD);
+	if (flags < 0) {
+		error("Failed to get fd flags: %s", strerror(errno));
+		close(listen_sock);
+	        free(listen_on_str);
+		return;
+	}
+
+	if (fcntl(listen_sock, F_SETFD, flags & ~FD_CLOEXEC) < 0) {
+		error("Failed to clear FD_CLOEXEC flag: %s", strerror(errno));
+		close(listen_sock);
+	        free(listen_on_str);
+		return;
+	}
+
+	listen_socks[num_listen_socks] = listen_sock;
+	listen_socks_no_close[num_listen_socks] = 1;
+	num_listen_socks++;
+
+	logit("Server listening on %s", listen_on_str);
+	free(listen_on_str);
+}
+#endif
+
 /*
  * Listen for TCP connections
  */
@@ -1100,17 +1240,26 @@
 	srclimit_init(options.max_startups, options.per_source_max_startups,
 	    options.per_source_masklen_ipv4, options.per_source_masklen_ipv6);
 
-	for (i = 0; i < options.num_listen_addrs; i++) {
-		listen_on_addrs(&options.listen_addrs[i]);
-		freeaddrinfo(options.listen_addrs[i].addrs);
-		free(options.listen_addrs[i].rdomain);
-		memset(&options.listen_addrs[i], 0,
-		    sizeof(options.listen_addrs[i]));
-	}
-	free(options.listen_addrs);
-	options.listen_addrs = NULL;
-	options.num_listen_addrs = 0;
-
+#ifdef SYSTEMD_SOCKET_ACTIVATION
+	if (systemd_num_listen_fds > 0)
+	{
+		int i;
+		for (i = 0; i < systemd_num_listen_fds; i++)
+			setup_systemd_socket(SYSTEMD_LISTEN_FDS_START + i);
+	} else
+#endif
+	{
+		for (i = 0; i < options.num_listen_addrs; i++) {
+			listen_on_addrs(&options.listen_addrs[i]);
+			freeaddrinfo(options.listen_addrs[i].addrs);
+			free(options.listen_addrs[i].rdomain);
+			memset(&options.listen_addrs[i], 0,
+			    sizeof(options.listen_addrs[i]));
+		}
+		free(options.listen_addrs);
+		options.listen_addrs = NULL;
+		options.num_listen_addrs = 0;
+	}
 	if (!num_listen_socks)
 		fatal("Cannot bind any address.");
 }
@@ -1165,7 +1314,7 @@
 		if (received_sigterm) {
 			logit("Received signal %d; terminating.",
 			    (int) received_sigterm);
-			close_listen_socks();
+			close_listen_socks(/* force = */ 1);
 			if (options.pid_file != NULL)
 				unlink(options.pid_file);
 			exit(received_sigterm == SIGTERM ? 0 : 255);
@@ -1179,7 +1328,7 @@
 		if (received_sighup) {
 			if (!lameduck) {
 				debug("Received SIGHUP; waiting for children");
-				close_listen_socks();
+				close_listen_socks(/* force = */ 0);
 				lameduck = 1;
 			}
 			if (listening <= 0) {
@@ -1306,7 +1455,7 @@
 				 * connection without forking.
 				 */
 				debug("Server will not fork when running in debugging mode.");
-				close_listen_socks();
+				close_listen_socks(/* force = */ 0);
 				*sock_in = *newsock;
 				*sock_out = *newsock;
 				close(startup_p[0]);
@@ -1340,7 +1489,7 @@
 				platform_post_fork_child();
 				startup_pipe = startup_p[1];
 				close_startup_pipes();
-				close_listen_socks();
+				close_listen_socks(/* force = */ 1);
 				*sock_in = *newsock;
 				*sock_out = *newsock;
 				log_init(__progname,
@@ -1711,6 +1860,15 @@
 			break;
 		}
 	}
+
+#ifdef SYSTEMD_SOCKET_ACTIVATION
+	r = get_systemd_listen_fds();
+	if (r < 0)
+	        fatal("Failed to get systemd socket fds: %s", strerror(-r));
+
+	systemd_num_listen_fds = r;
+#endif
+
 	if (rexeced_flag || inetd_flag)
 		rexec_flag = 0;
 	if (!test_flag && !do_dump_cfg && rexec_flag && !path_absolute(av[0]))
@@ -2126,6 +2284,7 @@
 			debug3_f("dup2 stdin: %s", strerror(errno));
 		if (dup2(STDIN_FILENO, STDOUT_FILENO) == -1)
 			debug3_f("dup2 stdout: %s", strerror(errno));
+
 		if (startup_pipe == -1)
 			close(REEXEC_STARTUP_PIPE_FD);
 		else if (startup_pipe != REEXEC_STARTUP_PIPE_FD) {
@@ -2135,6 +2294,13 @@
 			startup_pipe = REEXEC_STARTUP_PIPE_FD;
 		}
 
+	        /* Without systemd socket activation, we often have newsock == REEXEC_CONFIG_PASS_FD
+	         * here, and hence newsock gets closed by the dup2() below. But with systemd socket
+	         * activation, usually newsock != REEXEC_CONFIG_PASS_FD, and it is left open.
+	         *
+	         * Close it explicitly here. It was already dup()'d above to prepare for re-exec. */
+	        close(newsock);
+
 		if (dup2(config_s[1], REEXEC_CONFIG_PASS_FD) == -1)
 			debug3_f("dup2 config_s: %s", strerror(errno));
 		close(config_s[1]);
